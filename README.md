## Лабораторная работа 8

### Теоретическая справка
**Что такое алгоритмы STL?**
Контейнеры STL представляли бы собой красивую выдумку, достаточно далёкую от
практического использования (как и было в первые годы существования STL),
если бы не следующее обстоятельство: из-за единой общей природы всех контейнеров
основные алгоритмы, представляющие интерес на практике, могут быть реализованы
в обобщённом виде, применимом к любым типам контейнеров. Алгоритмы — это самая
объёмная и самая востребованная часть библиотеки. Предоставляется настолько много
алгоритмов, что для детального описания их всех не хватит и объёмной книги.
В данной лабораторной работе вам предстоит ознакомиться лишь с некоторыми из них.

**Использование алгоритмов STL**
* `std::find`
    ```cpp
        template< class InputIt, class T >
        InputIt find( InputIt first, InputIt last, const T& value );
    ```    
Данная функция ищет в диапазоне параметров [first, last) первый элемент, равный value

* `std::find_if` 
Находит позицию первого вхождения элемента, удовлетворяющего определенному условию,
в диапазон.
    ```cpp
    template<class InputIterator, class Predicate> 
    InputIterator find_if(InputIterator first, InputIterator last, Predicate pred);
    ```
`pred` - определенный пользователем объект функции предиката или лямбда-выражение,
определяющее условие, которое должно удовлетворяться искомым элементом. Предикат
берет один аргумент и возвращает `true `(условие удовлетворено) или `false` (условие
не удовлетворено). Подпись pred должна быть `bool pred(const T& arg)`;, где `T` — тип,
к которому можно явным образом привести `InputIterator` при сбросе ссылки. Ключевое
слово `const` показано только для демонстрации того, что объект функции или лямбда
не должен изменять аргумент. 

* `std::count_if`
     ```cpp
     template< class InputIt, class UnaryPredicate >
     typename iterator_traits<InputIt>::difference_type
     count_if( InputIt first, InputIt last, UnaryPredicate p );
     ```
Возвращает количество элементов в диапазоне [first, last), удовлетворяющих определенному
условию. Подсчитывает элементы, для которых предикат p возвращает значение true. О том,
что такое предикат, можно прочитать выше.

* `std::transform`
    ```cpp
       template <class InIter, class OutIter, class Funс>
	   OutIter transform(InIter start, InIter end,
				    OutIter result, Func unaryfunc);
       template <class InIter1, class InIter2, class OutIter, class Func>
	    OutIter transform(InIter1 start1, InIter1 end1, InIter2 start2,
				   OutIter result, Func binaryfunc);
	```
Применяет функцию к диапазону элементов и сохраняет результат в последовательности 
Алгоритм `transform()` применяет функцию к диапазону элементов и сохраняет результат
в последовательности, заданной параметром `result`. В первой форме диапазон задается
параметрами `start` и `end`. Применяемая функция задается параметром `unaryfunc`. 
Она принимает значение элемента в качестве параметра и должна возвратить преобразованное
значение.
Во второй форме алгоритма преобразование применяется с использованием бинарной функции,
которая принимает значение элемента из последовательности, предназначенного для преобразования,
в качестве первого параметра и элемент из второй последовательности в качестве второго параметра.
Обе версии возвращают итератор, указывающий на конец результирующей последовательности.

* `std::sort`
    ```cpp
       template<class RandomAccessIterator>
       void sort(
           RandomAccessIterator first, 
           RandomAccessIterator last
        );
        template<class RandomAccessIterator, class Predicate>
        void sort(
           RandomAccessIterator first, 
           RandomAccessIterator last, 
           Predicate comp
        );
    ```
Первая форма алгоритма использует дефолтный функтор сравнения, а вторая позволяет
задать его самостоятельно.
Компаратор(смотри вторую форму) — это определенный пользователем объект функции
или лямбда-выражение, который как бы учит
сортировать `sort`. Так, например, можно сортировать по:
Кратности на 3.
Четности или нечетности.
Изменить сторону сортировки на — по убыванию.
`sort` передает элементы компаратору, а компаратор проверяет их по вашему
алгоритму и передает `true` или `false`.

* `std::any_of`
    ```cpp
       template< class InputIt, class UnaryPredicate >
       bool any_of( InputIt first, InputIt last, UnaryPredicate p );
    ```
Проверяет, что предикат p возвращает значение `true` для хотя бы одного элемента
в диапазоне `[first, last)`.

**Что такое лямбда- функция? (`на примере std::find_if`)**
* Лямбда-выражение (или просто лямбда) в `C++11` — это удобный способ определения анонимного
объекта-функции непосредственно в месте его вызова или передачи в функцию в качестве аргумента.
Если нужна функция, можно описать её лямбдой, а не описывать отдельную функцию, загромождая код.
Удобно в `STL`. Удобно когда выражение короткое. Иначе код становится ужасно читаем. 
Лямбда-выражениями называются безымянные локальные функции, которые можно создавать
прямо внутри какого-либо выражения.
В этом примере лямбда-выражение передается в качестве аргумента функции `find_if`. 
Лямбда-выражение возвращает значение `true`, если его параметром является четное число
    ```cpp
       list<int> numbers; 
       numbers.push_back(13);  
       numbers.push_back(17);  
       numbers.push_back(42);  
       numbers.push_back(46);  
       numbers.push_back(99);  
       const list<int>::const_iterator result =   
       find_if(numbers.begin(), numbers.end(),[](int n) { return (n % 2) == 0; });
    ```   
Для полного понимания того, как использовать лямбда- выражения, следует заглянуть 
[сюда](https://msdn.microsoft.com/ru-ru/library/dd293599.aspx)

**Примеры, с которыми следует ознакомиться**
* [Здесь](https://github.com/bmstu-iu8-cpp/cpp-beginner-2017/tree/master/lab8)
